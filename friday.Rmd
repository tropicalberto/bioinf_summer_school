---
title: “Friday notes"
author: “Alberto Gil"
date: " `r format(Sys.time(), '%A %B %d, %Y (%H:%M:%S)')` "
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: hide
  word_document: default
geometry: a4paper,headheight=80pt,bottom=30mm,footskip=60pt,right=16mm,left=22mm
fontsize: 9pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Session 1 Single RNAseq

Koen van der Berge, Ghent University

Reverse transcription of a single cell RNA is very inefficient 

Applications: 
* Dissecting cell states
* Transcriptional regulation
* Assess technical variability from single cells with sequecing (or biological variability)
* identify rare cell types
* Track development of single cells 

Cell identity: cell type (permanent type) and cell state (transient state)

scRNA protocols:
* droplet-based. low signal to noise ratio. no transcript level resolution, only gene resolution
* platelet based. high signal to noise ratio. transcript level resolution, we can use Salmon with this kind of data

cell barcode is the same for all oligonucleotides in a single bead

UMI --> between cell normalization is really important

0 in plate-based SMART-Seq because biological effects and technical effects 
droplet based counts: counts are much lower compared to plate based methods

sc methods have much more noise than bulk RNAseq 

non linear dimensionality methods like tSNE: distance between points is non linear, beware that. Useful for 2 first dimensions, for more dimensions it tends to break down 

NB distribution doesnt fit well data from plate based methods (because we have a lot of 0 counts)

inflation is not required for droplet based methods ? (there's no peak at 0's in the gene expression distribution)

**Batch effects**. They can induce the generation of artificial clusters with dimensionality reduction. Possible effects: 
* Nuisance effecrs: detection rate is a technical variability that the ata has. That is why PCA is not appropiate for scRNA. Thsi is due to the high balance of 0's 

scRNAseq data approaches. First dimensionality reduction. then DE. Higher chance to have more FPs, we are using the data twice! (high FDR) 

# Session 2 Mass spectrometry based proteomics

Raw data: **infer info from peptides**, not from proteins! We latter need to infer from which protein were they coming from.

* LC = liquid cromatography
* GC = gas chromatrography

Uniprot: to retrieve info from proteins/peptides 

PSM score: the higher the better. Done 2 types: 
* for the correct PSMs 
* for the reverse database (from proteins database)

Labelled Isobaric tagging: depending of the height of the sample barcode peaks (slide 25) we can quantify the relative proportions of the peptides for each of the samples 

# Session 2: practical Proteomics data analysis

## Libraries
```{r, message=FALSE}
library("MSnbase")
library("msdata")
```

## Loading raw data 
```{r}
basename(fl3 <- msdata::proteomics(full.name = TRUE, pattern = "MS3TMT11"))
```

* mode = onDisk. don't load the whole data into memory (it's too big), read only a subset of it 
```{r}
(rw3 <- readMSData(fl3, mode = "onDisk"))
```

MS1 is not centroided, MS2 and MS3 are centroided 
```{r}
table(msLevel(rw3), centroided(rw3))
```

Retention time: 
```{r}
# rtime(msLevel(rw3))
```

## Loading identification data

```{r}
basename(idf <- msdata::ident(full.name = TRUE))
```

```{r}
iddf <- readMzIdData(idf)
iddf
```

```{r}
library('ggplot2')
```

color: whether peptide comes from a decoy database or not 

Separation with isDecoy is not good from what we can see in the plot 
```{r}
ggplot(iddf, aes(x = MS.GF.RawScore, colour = isDecoy)) +
    geom_density()
```

## Combining raw and identification data 

```{r}
basename(quantFile <- dir(system.file(package = "MSnbase", dir = "extdata"),
                 full.name = TRUE, pattern = "mzXML$"))
```

```{r}
basename(identFile <- dir(system.file(package = "MSnbase", dir = "extdata"),
                          full.name = TRUE, pattern = "dummyiTRAQ.mzid"))
```

```{r}
msexp <- readMSData(quantFile)
fvarLabels(msexp)
```

```{r}
msexp <- addIdentificationData(msexp, identFile)
fvarLabels(msexp)
```

## Quantitative data

```{r}
data(itraqdata)
itraqdata
```

```{r}
msnset <- quantify(itraqdata, method = "trap", reporters = iTRAQ4)
msnset
```

```{r}
exprs(msnset[,1])
```

```{r}
plot(itraqdata[[1]], reporters = iTRAQ4, full = TRUE)
```

```{r}
exprs(msnset)[1,]
```

Annotation data: 
```{r}
fData(msnset)[1, ]
```

```{r}
f <- "./cptac_peptides.txt"
getEcols(f, split = "\t")
```

```{r}
e <- grepEcols(f, "Intensity ", split = "\t") ## careful at the space!
(cptac <- readMSnSet2(f, ecol = e,
                      fnames = "Sequence",
                      sep = "\t"))
```

Selection of feature data columns with shiny app (can also be done manually if you know the name of the columns)
```{r}
# cptac <- selectFeatureData(cptac)
```

```{r}
cptac <- selectFeatureData(cptac,
                           fcol = c("Proteins",
                                    "Potential.contaminant",
                                    "Reverse",
                                    "Sequence"))
```

Sample metadata:
```{r}
cptac$group <- rep(c("6A", "6B"), each = 3)
cptac$sample <- rep(7:9, 2)
sampleNames(cptac) <- sub("Intensity.", "", sampleNames(cptac))
pData(cptac)
```

## Data processing

```{r}
table(sel_conts <- fData(cptac)$Potential.contaminant != "+")
```

```{r}
table(sel_rev <- fData(cptac)$Reverse != "+")
```

```{r}
(cptac <- cptac[sel_conts & sel_rev, ])
```

### Notes on missing values 

Some software uses 0 fir NAs 
```{r}
anyNA(cptac)
```


```{r}
exprs(cptac)[exprs(cptac) == 0] <- NA
table(is.na(exprs(cptac)))
```

```{r}
napac <- cptac
exprs(napac)[!is.na(exprs(napac))] <- 1
naplot(napac)
```

```{r}
fData(cptac)$nNA <- apply(exprs(cptac), 1, function(x) sum(is.na(x)))
table(fData(cptac)$nNA)
```

```{r}
(cptac <- filterNA(cptac))
```

### Log transformation 

```{r}
(cptac <- log(cptac, base = 2))
```

### Normalization
Quantile normalization
```{r}
(cptac <- normalise(cptac, method = "quantiles"))
```

### Summarization
```{r}
(cptac <- combineFeatures(cptac, fcol = "Proteins", method = "mean"))
```

```{r}
sessionInfo()
```

# Session 3: 
